# Tutorial {#tutorial}

The library provides some convenient template classes to cover common needs in transfer matrix computations.
This page describes, via an example, how the library is intended to be used.

The goal is to define the action of a transfer matrix

$$T = \prod_i R_i $$

on some chosen basis \f$\{|e_i \rangle\}\f$.

## Data types

The snippets of code from this section come from the [examples/ising](@ref examples) section [ising.hpp](../examples/ising/ising.hpp) and [ising.cpp](../examples/ising/ising.cpp) files, which define 

### Built-in key types

Usually, we represent basis states as a sequence of numbers. An easy example is the Ising model, for which a link state can be represented as a sequence of +1 and -1's. The library provides two types for representing sequences of numbers:

* [key_int8_t](@ref key_int8_t)
* [key_64_bit_t](@ref key_64_bit_t) 

It is a good practice to define your own key type inheriting from these; in the snippet below for instance we create a `Key` class which is a sequence of 3-bits numbers of length `SIZE`, stored in a 64-bit integer. We also define a `shift_right` method that cyclically permutes the entries of this key:

@snippet ../examples/ising/ising.hpp Defining a key type

We can access elements, set their values and print the key:

@snippet ../examples/ising/ising.hpp Operations on keys

### Defining a basis

After defining a key type, we need to define a type for representing basis vectors, and operations on basis vectors.
For this purpose, the class [BasisVector<K, V>](@ref BasisVector) holds a `(key, value)` pair.
A good practice is to derive from this class in order to define a particular basis of a space of states:

@snippet ../examples/ising/ising.hpp Defining a basis

In this example, we create a class `IsingPM` for representing basis states. We can define methods to operate on these states:

@snippet ../examples/ising/ising.hpp Operations on basis states

### Vectors

To represent a general vector, which is a sum of basis vectors, the library exposes
a class [Vector<BasisVector>](@ref Vector) which stores several `(key, value)` pairs in a hash table (or dictionary),
using the hash table implementation of the C++ standard library `std::unordered_map`.
This data structure allows for fast insertion, lookup, and deletion.

Like for `BasisVector`s, it is a good practice to inherit from the `Vector` class:

@snippet ../examples/ising/ising.hpp Defining a vector class
This again gives some flexibility to add methods and data to the state.

One can multiply a vector by a scalar, add a basis vector to a vector, or add vectors together.
Vectors can be looped through, or looped through and drained at the same time, which is useful to 
limit memory usage. 
To prevent overflowing of vector components, one can factorize the norm of the vector.
The norm of the vector is stored as an arbitrary precision number, which cannot overflow.

@snippet ../examples/ising/ising.hpp test_vector

Vectors can be iterated over with 
```cpp
for (auto it = v.begin(); it != v.end(); it++) { /* do stuff */ }
```
The library also provides a draining iterator, which empties the vector as it goes:

@snippet ../examples/ising/ising.hpp draining_iterator

The code above iterates over the state, applies the \f$R\f$-matrix to each of its components, storing the result in a vector `tmp`. Then we do a swap to bring back the result to the current vector.

## Transfer matrix

### Multiplication

Once the \f$R\f$-matrices are defined, the transfer matrix is easy to define:

@snippet ../examples/ising/ising.hpp transfer matrix

Now to multiply a state by the transfer matrix we just need to call `transfer` and feed a vector for storing the intermediate results:

@snippet ../examples/ising/ising.hpp test_transfer

### Display

For debugging purposes, it is convenient to be able to visualise coefficients of the matrix, not only to define the multiplication function. For this, the library provides a class [Matrix](@ref Matrix). To construct a `Matrix` object, one needs to give two vectors, the first initialised. The program will print the coefficients of the matrix in the space generated by repeated action of the matrix on the initial vector. For instance, in our Ising example:

@snippet ../examples/ising/ising.cpp test_matrix

The class also lets us print the basis:

@snippet ../examples/ising/ising.cpp print_state_table
